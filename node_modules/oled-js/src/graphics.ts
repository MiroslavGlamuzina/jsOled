interface Pixel {
  [index: number]: number;
}

interface PixelOptions {
  pixels:  Pixel[];
  sync?: boolean;
}

interface LineOptions {
  start: [number, number];
  end: [number, number];
  color: number;
  sync?: boolean;
}

const drawLine = function(options: LineOptions) : void {
  const immed = (options.sync) ? true : options.sync;
  const [x0, y0] = options.start;
  const [x1, y1] = options.end;

  const dx = Math.abs(x1 - x0), 
        sx = x0 < x1 ? 1 : -1,
        dy = Math.abs(y1 - y0), 
        sy = y0 < y1 ? 1 : -1;

  let err = (dx > dy ? dx : -dy) / 2;
  let x = x0, y = y0;

  while (true) {
    const pixel = {pixels: [[x, y, options.color]], sync: false}; 
    drawPixel(pixel);

    if (x === x1 && y === y1) break;

    const e2 = err;

    if (e2 > -dx) {
      err -= dy; 
      x += sx;
    }

    if (e2 < dy) {
      err += dx; 
      y += sy;
    }
  }

  if (immed) {
    //this._updateDirtyBytes(this.dirtyBytes);
  }
}

// draw one or many pixels on oled
const drawPixel = function(options: PixelOptions) : void {
  const immed = (options.sync) ? true : options.sync;

  options.pixels.forEach((el) => {
    // return if the pixel is out of range
    const x = el[0], y = el[1], color = el[2];
    if (x > this.WIDTH || y > this.HEIGHT) return;

    const page = Math.floor(y / 8),
          pageShift = 0x01 << (y - 8 * page);

    const byte = x + (this.WIDTH * page);

    if (color === 0) {
      this.buffer[byte] &= ~pageShift;
    } else {
      this.buffer[byte] |= pageShift;
    }

    // push byte to dirty if not already there
    if (this.dirtyBytes.indexOf(byte) === -1) {
      this.dirtyBytes.push(byte);
    }
  });

  if (immed) {
  //  this._updateDirtyBytes(this.dirtyBytes);
  }
}

